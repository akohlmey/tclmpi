<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TclMPI: TclMPI wrapper functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TclMPI
   &#160;<span id="projectnumber">1.2</span>
   </div>
   <div id="projectbrief">Tcl Bindings for MPI</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__wrappers.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">TclMPI wrapper functions</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf143e6414be1d8e76b7dc88208df68b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wrappers.html#gaf143e6414be1d8e76b7dc88208df68b2">TclMPI_Initialized</a> (ClientData nodata, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[])</td></tr>
<tr class="separator:gaf143e6414be1d8e76b7dc88208df68b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b3afff28c4aa75821e23176db660138"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wrappers.html#ga3b3afff28c4aa75821e23176db660138">TclMPI_Finalized</a> (ClientData nodata, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[])</td></tr>
<tr class="separator:ga3b3afff28c4aa75821e23176db660138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga738cbe476e7ccfd4aced07b4dd433587"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wrappers.html#ga738cbe476e7ccfd4aced07b4dd433587">TclMPI_Init</a> (ClientData nodata, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[])</td></tr>
<tr class="separator:ga738cbe476e7ccfd4aced07b4dd433587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad87e089160b2db00ac6ff1178600ad8b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wrappers.html#gad87e089160b2db00ac6ff1178600ad8b">TclMPI_Conv_set</a> (ClientData nodata, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[])</td></tr>
<tr class="separator:gad87e089160b2db00ac6ff1178600ad8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85c731e1706521882659eced81473680"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wrappers.html#ga85c731e1706521882659eced81473680">TclMPI_Conv_get</a> (ClientData nodata, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[])</td></tr>
<tr class="separator:ga85c731e1706521882659eced81473680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45ed08039c57d730f66d956e87431d7c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wrappers.html#ga45ed08039c57d730f66d956e87431d7c">TclMPI_Finalize</a> (ClientData nodata, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[])</td></tr>
<tr class="separator:ga45ed08039c57d730f66d956e87431d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7438f828128f675a55088612321a4ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wrappers.html#gae7438f828128f675a55088612321a4ba">TclMPI_Abort</a> (ClientData nodata, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[])</td></tr>
<tr class="separator:gae7438f828128f675a55088612321a4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70e54af5e85f8f41107824a9ab2e7c59"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wrappers.html#ga70e54af5e85f8f41107824a9ab2e7c59">TclMPI_Comm_size</a> (ClientData nodata, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[])</td></tr>
<tr class="separator:ga70e54af5e85f8f41107824a9ab2e7c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga796fa40d25d18e3a473db9cab380b0dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wrappers.html#ga796fa40d25d18e3a473db9cab380b0dc">TclMPI_Comm_rank</a> (ClientData nodata, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[])</td></tr>
<tr class="separator:ga796fa40d25d18e3a473db9cab380b0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d90b89b0bcdd1f21c2c358d43d295b7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wrappers.html#ga3d90b89b0bcdd1f21c2c358d43d295b7">TclMPI_Comm_split</a> (ClientData nodata, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[])</td></tr>
<tr class="separator:ga3d90b89b0bcdd1f21c2c358d43d295b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7d6a1f6657d02bec174b70ba3f1e13d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wrappers.html#gab7d6a1f6657d02bec174b70ba3f1e13d">TclMPI_Comm_free</a> (ClientData nodata, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[])</td></tr>
<tr class="separator:gab7d6a1f6657d02bec174b70ba3f1e13d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad318014c7117bce997939cc6ed2d30e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wrappers.html#gad318014c7117bce997939cc6ed2d30e4">TclMPI_Barrier</a> (ClientData nodata, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[])</td></tr>
<tr class="separator:gad318014c7117bce997939cc6ed2d30e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26285fa0f7e6b299ad45359f60e6cfb7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wrappers.html#ga26285fa0f7e6b299ad45359f60e6cfb7">TclMPI_Bcast</a> (ClientData nodata, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[])</td></tr>
<tr class="separator:ga26285fa0f7e6b299ad45359f60e6cfb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga337b5793693835724b4e705e533a5091"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wrappers.html#ga337b5793693835724b4e705e533a5091">TclMPI_Scatter</a> (ClientData nodata, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[])</td></tr>
<tr class="separator:ga337b5793693835724b4e705e533a5091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b888470790e13b0e78741a328741bd7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wrappers.html#ga9b888470790e13b0e78741a328741bd7">TclMPI_Allgather</a> (ClientData nodata, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[])</td></tr>
<tr class="separator:ga9b888470790e13b0e78741a328741bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d64d68f8f2ddbabece91704398d1271"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wrappers.html#ga8d64d68f8f2ddbabece91704398d1271">TclMPI_Gather</a> (ClientData nodata, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[])</td></tr>
<tr class="separator:ga8d64d68f8f2ddbabece91704398d1271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e628df64da0035823328bbc5e0ef6a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wrappers.html#ga6e628df64da0035823328bbc5e0ef6a4">TclMPI_Allreduce</a> (ClientData nodata, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[])</td></tr>
<tr class="separator:ga6e628df64da0035823328bbc5e0ef6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21fffcb1b06117177f8cb64c0d13b4cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wrappers.html#ga21fffcb1b06117177f8cb64c0d13b4cf">TclMPI_Reduce</a> (ClientData nodata, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[])</td></tr>
<tr class="separator:ga21fffcb1b06117177f8cb64c0d13b4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcf9e8effd1a99b4aed1e17e8b9bc2e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wrappers.html#gafcf9e8effd1a99b4aed1e17e8b9bc2e3">TclMPI_Send</a> (ClientData nodata, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[])</td></tr>
<tr class="separator:gafcf9e8effd1a99b4aed1e17e8b9bc2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a80dad483292f282deb68f37b014bb8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wrappers.html#ga5a80dad483292f282deb68f37b014bb8">TclMPI_Isend</a> (ClientData nodata, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[])</td></tr>
<tr class="separator:ga5a80dad483292f282deb68f37b014bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf47d8f1880c12269033d3c85aa561e9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wrappers.html#gadf47d8f1880c12269033d3c85aa561e9">TclMPI_Recv</a> (ClientData nodata, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[])</td></tr>
<tr class="separator:gadf47d8f1880c12269033d3c85aa561e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23b7bfee001ce295267c82286eacb977"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wrappers.html#ga23b7bfee001ce295267c82286eacb977">TclMPI_Irecv</a> (ClientData nodata, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[])</td></tr>
<tr class="separator:ga23b7bfee001ce295267c82286eacb977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7f8f9e8a2e0415c15b859b742335f6f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wrappers.html#gab7f8f9e8a2e0415c15b859b742335f6f">TclMPI_Probe</a> (ClientData nodata, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[])</td></tr>
<tr class="separator:gab7f8f9e8a2e0415c15b859b742335f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f7e89c72b47081da83f0c724d853d68"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wrappers.html#ga2f7e89c72b47081da83f0c724d853d68">TclMPI_Iprobe</a> (ClientData nodata, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[])</td></tr>
<tr class="separator:ga2f7e89c72b47081da83f0c724d853d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69a2797d86eb85cf481686f7f13d2470"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wrappers.html#ga69a2797d86eb85cf481686f7f13d2470">TclMPI_Wait</a> (ClientData nodata, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[])</td></tr>
<tr class="separator:ga69a2797d86eb85cf481686f7f13d2470"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae7438f828128f675a55088612321a4ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7438f828128f675a55088612321a4ba">&#9670;&nbsp;</a></span>TclMPI_Abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TclMPI_Abort </td>
          <td>(</td>
          <td class="paramtype">ClientData&#160;</td>
          <td class="paramname"><em>nodata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Interp *&#160;</td>
          <td class="paramname"><em>interp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Obj *const&#160;</td>
          <td class="paramname"><em>objv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>wrapper for MPI_Abort() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodata</td><td>ignored </td></tr>
    <tr><td class="paramname">interp</td><td>current Tcl interpreter </td></tr>
    <tr><td class="paramname">objc</td><td>number of argument objects </td></tr>
    <tr><td class="paramname">objv</td><td>list of argument object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TCL_OK or TCL_ERROR</dd></dl>
<p>This function translates the Tcl string representing a communicator into the corresponding MPI communicator and then calls MPI_Abort(). </p>

</div>
</div>
<a id="ga9b888470790e13b0e78741a328741bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b888470790e13b0e78741a328741bd7">&#9670;&nbsp;</a></span>TclMPI_Allgather()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TclMPI_Allgather </td>
          <td>(</td>
          <td class="paramtype">ClientData&#160;</td>
          <td class="paramname"><em>nodata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Interp *&#160;</td>
          <td class="paramname"><em>interp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Obj *const&#160;</td>
          <td class="paramname"><em>objv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>wrapper for MPI_Allgather() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodata</td><td>ignored </td></tr>
    <tr><td class="paramname">interp</td><td>current Tcl interpreter </td></tr>
    <tr><td class="paramname">objc</td><td>number of argument objects </td></tr>
    <tr><td class="paramname">objv</td><td>list of argument object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TCL_OK or TCL_ERROR</dd></dl>
<p>This function implements a gather operation that collects data for TclMPI. This operation does not accept the <a class="el" href="namespacetclmpi.html#ab65b00584fb79d516e653ea35dece54e" title="constant for automatic data type">tclmpi::auto</a> data type, also support for types outside of <a class="el" href="namespacetclmpi.html#a1cabae47e0cff6dfb26f3013347158ac" title="constant for integer data type">tclmpi::int</a> and <a class="el" href="namespacetclmpi.html#a8e4cded65a76ead28e3083f1c046234c" title="constant for double data type">tclmpi::double</a> is incomplete. The length of the data is inferred from the data object passed to this function and thus a 'count' argument is not needed. The number of data items has to be the same on all processes on the communicator.</p>
<p>The result is converted back into Tcl objects and passed up as result value to the calling Tcl code on all processors. If the MPI call failed, an MPI error message is passed up as result instead. </p>

</div>
</div>
<a id="ga6e628df64da0035823328bbc5e0ef6a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e628df64da0035823328bbc5e0ef6a4">&#9670;&nbsp;</a></span>TclMPI_Allreduce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TclMPI_Allreduce </td>
          <td>(</td>
          <td class="paramtype">ClientData&#160;</td>
          <td class="paramname"><em>nodata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Interp *&#160;</td>
          <td class="paramname"><em>interp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Obj *const&#160;</td>
          <td class="paramname"><em>objv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>wrapper for MPI_Allreduce() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodata</td><td>ignored </td></tr>
    <tr><td class="paramname">interp</td><td>current Tcl interpreter </td></tr>
    <tr><td class="paramname">objc</td><td>number of argument objects </td></tr>
    <tr><td class="paramname">objv</td><td>list of argument object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TCL_OK or TCL_ERROR</dd></dl>
<p>This function implements a reduction plus broadcast function for TclMPI. This operation does not accept the <a class="el" href="namespacetclmpi.html#ab65b00584fb79d516e653ea35dece54e" title="constant for automatic data type">tclmpi::auto</a> data type, also support for types outside of <a class="el" href="namespacetclmpi.html#a1cabae47e0cff6dfb26f3013347158ac" title="constant for integer data type">tclmpi::int</a> and <a class="el" href="namespacetclmpi.html#a8e4cded65a76ead28e3083f1c046234c" title="constant for double data type">tclmpi::double</a> is incomplete. The length of the data is inferred from the data object passed to this function and thus a 'count' argument is not needed.</p>
<p>The result is converted back into Tcl objects and passed up as result value to the calling Tcl code. If the MPI call failed, an MPI error message is passed up as result instead. </p>

</div>
</div>
<a id="gad318014c7117bce997939cc6ed2d30e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad318014c7117bce997939cc6ed2d30e4">&#9670;&nbsp;</a></span>TclMPI_Barrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TclMPI_Barrier </td>
          <td>(</td>
          <td class="paramtype">ClientData&#160;</td>
          <td class="paramname"><em>nodata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Interp *&#160;</td>
          <td class="paramname"><em>interp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Obj *const&#160;</td>
          <td class="paramname"><em>objv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>wrapper for MPI_Barrier() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodata</td><td>ignored </td></tr>
    <tr><td class="paramname">interp</td><td>current Tcl interpreter </td></tr>
    <tr><td class="paramname">objc</td><td>number of argument objects </td></tr>
    <tr><td class="paramname">objv</td><td>list of argument object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TCL_OK or TCL_ERROR</dd></dl>
<p>This function translates the Tcl string representing a communicator into the corresponding MPI communicator and then calls MPI_Barrier(). If the MPI call failed, an MPI error message is passed up as result. </p>

</div>
</div>
<a id="ga26285fa0f7e6b299ad45359f60e6cfb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26285fa0f7e6b299ad45359f60e6cfb7">&#9670;&nbsp;</a></span>TclMPI_Bcast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TclMPI_Bcast </td>
          <td>(</td>
          <td class="paramtype">ClientData&#160;</td>
          <td class="paramname"><em>nodata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Interp *&#160;</td>
          <td class="paramname"><em>interp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Obj *const&#160;</td>
          <td class="paramname"><em>objv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>wrapper for MPI_Bcast() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodata</td><td>ignored </td></tr>
    <tr><td class="paramname">interp</td><td>current Tcl interpreter </td></tr>
    <tr><td class="paramname">objc</td><td>number of argument objects </td></tr>
    <tr><td class="paramname">objv</td><td>list of argument object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TCL_OK or TCL_ERROR</dd></dl>
<p>This function implements a broadcast function for TclMPI. Unlike in the C bindings, the length of the data is inferred from the data object passed to this function and thus a 'count' argument is not needed. Only a limited number of data types are currently supported, since Tcl has a limited number of "native" data types. The <a class="el" href="namespacetclmpi.html#ab65b00584fb79d516e653ea35dece54e" title="constant for automatic data type">tclmpi::auto</a> data type transfers the internal string representation of an object, while the other data types convert data to native data types as needed, with all non-representable data translated into either 0 or 0.0. In all cases, two broadcasts are needed. The first to transmit the amount of data being sent so that a suitable receive buffer can be set up.</p>
<p>The result of the broadcast is converted back into Tcl objects and passed up as result value to the calling Tcl code. If the MPI call failed, an MPI error message is passed up as result instead. </p>

</div>
</div>
<a id="gab7d6a1f6657d02bec174b70ba3f1e13d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7d6a1f6657d02bec174b70ba3f1e13d">&#9670;&nbsp;</a></span>TclMPI_Comm_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TclMPI_Comm_free </td>
          <td>(</td>
          <td class="paramtype">ClientData&#160;</td>
          <td class="paramname"><em>nodata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Interp *&#160;</td>
          <td class="paramname"><em>interp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Obj *const&#160;</td>
          <td class="paramname"><em>objv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>wrapper for MPI_Comm_free() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodata</td><td>ignored </td></tr>
    <tr><td class="paramname">interp</td><td>current Tcl interpreter </td></tr>
    <tr><td class="paramname">objc</td><td>number of argument objects </td></tr>
    <tr><td class="paramname">objv</td><td>list of argument object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TCL_OK or TCL_ERROR</dd></dl>
<p>This function deletes a defined MPI communicator and removes its Tcl representation from the local translation tables. </p>

</div>
</div>
<a id="ga796fa40d25d18e3a473db9cab380b0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga796fa40d25d18e3a473db9cab380b0dc">&#9670;&nbsp;</a></span>TclMPI_Comm_rank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TclMPI_Comm_rank </td>
          <td>(</td>
          <td class="paramtype">ClientData&#160;</td>
          <td class="paramname"><em>nodata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Interp *&#160;</td>
          <td class="paramname"><em>interp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Obj *const&#160;</td>
          <td class="paramname"><em>objv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>wrapper for MPI_Comm_rank() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodata</td><td>ignored </td></tr>
    <tr><td class="paramname">interp</td><td>current Tcl interpreter </td></tr>
    <tr><td class="paramname">objc</td><td>number of argument objects </td></tr>
    <tr><td class="paramname">objv</td><td>list of argument object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TCL_OK or TCL_ERROR</dd></dl>
<p>This function translates the Tcl string representing a communicator into the corresponding MPI communicator and then calls MPI_Comm_rank() on it. The resulting number is passed to Tcl as result or the MPI error message is passed up similarly. </p>

</div>
</div>
<a id="ga70e54af5e85f8f41107824a9ab2e7c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70e54af5e85f8f41107824a9ab2e7c59">&#9670;&nbsp;</a></span>TclMPI_Comm_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TclMPI_Comm_size </td>
          <td>(</td>
          <td class="paramtype">ClientData&#160;</td>
          <td class="paramname"><em>nodata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Interp *&#160;</td>
          <td class="paramname"><em>interp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Obj *const&#160;</td>
          <td class="paramname"><em>objv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>wrapper for MPI_Comm_size() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodata</td><td>ignored </td></tr>
    <tr><td class="paramname">interp</td><td>current Tcl interpreter </td></tr>
    <tr><td class="paramname">objc</td><td>number of argument objects </td></tr>
    <tr><td class="paramname">objv</td><td>list of argument object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TCL_OK or TCL_ERROR</dd></dl>
<p>This function translates the Tcl string representing a communicator into the corresponding MPI communicator and then calls MPI_Comm_size() on it. The resulting number is passed to Tcl as result or the MPI error message is passed up similarly. </p>

</div>
</div>
<a id="ga3d90b89b0bcdd1f21c2c358d43d295b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d90b89b0bcdd1f21c2c358d43d295b7">&#9670;&nbsp;</a></span>TclMPI_Comm_split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TclMPI_Comm_split </td>
          <td>(</td>
          <td class="paramtype">ClientData&#160;</td>
          <td class="paramname"><em>nodata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Interp *&#160;</td>
          <td class="paramname"><em>interp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Obj *const&#160;</td>
          <td class="paramname"><em>objv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>wrapper for MPI_Comm_split() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodata</td><td>ignored </td></tr>
    <tr><td class="paramname">interp</td><td>current Tcl interpreter </td></tr>
    <tr><td class="paramname">objc</td><td>number of argument objects </td></tr>
    <tr><td class="paramname">objv</td><td>list of argument object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TCL_OK or TCL_ERROR</dd></dl>
<p>This function translates the Tcl string representing a communicator into the corresponding MPI communicator also checks and converts the values for 'color' and 'key' and then calls MPI_Comm_split(). The resulting communicator is added to the internal communicator map linked list and its string representation is passed to Tcl as result. If the MPI call failed, the MPI error message is passed up similarly. </p>

</div>
</div>
<a id="ga85c731e1706521882659eced81473680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85c731e1706521882659eced81473680">&#9670;&nbsp;</a></span>TclMPI_Conv_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TclMPI_Conv_get </td>
          <td>(</td>
          <td class="paramtype">ClientData&#160;</td>
          <td class="paramname"><em>nodata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Interp *&#160;</td>
          <td class="paramname"><em>interp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Obj *const&#160;</td>
          <td class="paramname"><em>objv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get error handler string for data conversions in TclMPI </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodata</td><td>ignored </td></tr>
    <tr><td class="paramname">interp</td><td>current Tcl interpreter </td></tr>
    <tr><td class="paramname">objc</td><td>number of argument objects </td></tr>
    <tr><td class="paramname">objv</td><td>list of argument object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TCL_OK</dd></dl>
<p>This function returns which error handler is currently active for data conversions in TclMPI. For details see <a class="el" href="group__wrappers.html#gad87e089160b2db00ac6ff1178600ad8b">TclMPI_Conv_set()</a>.</p>
<p>There is no equivalent MPI function for this, since there are no data conversions in C or C++. </p>

</div>
</div>
<a id="gad87e089160b2db00ac6ff1178600ad8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad87e089160b2db00ac6ff1178600ad8b">&#9670;&nbsp;</a></span>TclMPI_Conv_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TclMPI_Conv_set </td>
          <td>(</td>
          <td class="paramtype">ClientData&#160;</td>
          <td class="paramname"><em>nodata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Interp *&#160;</td>
          <td class="paramname"><em>interp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Obj *const&#160;</td>
          <td class="paramname"><em>objv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set error handler for data conversions in TclMPI </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodata</td><td>ignored </td></tr>
    <tr><td class="paramname">interp</td><td>current Tcl interpreter </td></tr>
    <tr><td class="paramname">objc</td><td>number of argument objects </td></tr>
    <tr><td class="paramname">objv</td><td>list of argument object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TCL_OK or TCL_ERROR</dd></dl>
<p>This function sets what action TclMPI should take if a conversion of a data element to the requested integer or double data type fails. There are currently three handlers implemented: <a class="el" href="group__supportfn.html#ga59fd3e392fc35fdd36b59daf2a0fbba1">TCLMPI_ERROR</a>, <a class="el" href="group__supportfn.html#ga28af21107816287d72747f841ef917ea">TCLMPI_ABORT</a>, and <a class="el" href="group__supportfn.html#gaa79d87087661e7ac451d2406b6cdcec1">TCLMPI_TOZERO</a>.</p>
<p>For <a class="el" href="group__supportfn.html#ga59fd3e392fc35fdd36b59daf2a0fbba1">TCLMPI_ERROR</a> a Tcl error is raised and TclMPI returns to the calling function. For <a class="el" href="group__supportfn.html#ga28af21107816287d72747f841ef917ea">TCLMPI_ABORT</a> an error message is written to the error output and parallel execution on the current communicator is terminated via MPI_Abort(). For <a class="el" href="group__supportfn.html#gaa79d87087661e7ac451d2406b6cdcec1">TCLMPI_TOZERO</a> the error is silently ignored and the data element set to zero.</p>
<p>There is no equivalent MPI function for this, since there are no data conversions in C or C++. </p>

</div>
</div>
<a id="ga45ed08039c57d730f66d956e87431d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45ed08039c57d730f66d956e87431d7c">&#9670;&nbsp;</a></span>TclMPI_Finalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TclMPI_Finalize </td>
          <td>(</td>
          <td class="paramtype">ClientData&#160;</td>
          <td class="paramname"><em>nodata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Interp *&#160;</td>
          <td class="paramname"><em>interp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Obj *const&#160;</td>
          <td class="paramname"><em>objv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>wrapper for MPI_Finalize() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodata</td><td>ignored </td></tr>
    <tr><td class="paramname">interp</td><td>current Tcl interpreter </td></tr>
    <tr><td class="paramname">objc</td><td>number of argument objects </td></tr>
    <tr><td class="paramname">objv</td><td>list of argument object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TCL_OK or TCL_ERROR</dd></dl>
<p>This function does a little more than just calling MPI_Finalize(). It also tries to detect whether MPI_Init() or MPI_Finialize() have been called before (from Tcl) and then creates a (catchable) Tcl error instead of an (uncatchable) MPI error. </p>

</div>
</div>
<a id="ga3b3afff28c4aa75821e23176db660138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b3afff28c4aa75821e23176db660138">&#9670;&nbsp;</a></span>TclMPI_Finalized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TclMPI_Finalized </td>
          <td>(</td>
          <td class="paramtype">ClientData&#160;</td>
          <td class="paramname"><em>nodata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Interp *&#160;</td>
          <td class="paramname"><em>interp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Obj *const&#160;</td>
          <td class="paramname"><em>objv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>wrapper for MPI_Finalized() </p><dl class="section return"><dt>Returns</dt><dd>TCL_OK or TCL_ERROR</dd></dl>
<p>This function checks whether the MPI environment has been shut down. </p>

</div>
</div>
<a id="ga8d64d68f8f2ddbabece91704398d1271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d64d68f8f2ddbabece91704398d1271">&#9670;&nbsp;</a></span>TclMPI_Gather()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TclMPI_Gather </td>
          <td>(</td>
          <td class="paramtype">ClientData&#160;</td>
          <td class="paramname"><em>nodata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Interp *&#160;</td>
          <td class="paramname"><em>interp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Obj *const&#160;</td>
          <td class="paramname"><em>objv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>wrapper for MPI_Gather() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodata</td><td>ignored </td></tr>
    <tr><td class="paramname">interp</td><td>current Tcl interpreter </td></tr>
    <tr><td class="paramname">objc</td><td>number of argument objects </td></tr>
    <tr><td class="paramname">objv</td><td>list of argument object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TCL_OK or TCL_ERROR</dd></dl>
<p>This function implements a gather operation that collects data for TclMPI. This operation does not accept the <a class="el" href="namespacetclmpi.html#ab65b00584fb79d516e653ea35dece54e" title="constant for automatic data type">tclmpi::auto</a> data type, also support for types outside of <a class="el" href="namespacetclmpi.html#a1cabae47e0cff6dfb26f3013347158ac" title="constant for integer data type">tclmpi::int</a> and <a class="el" href="namespacetclmpi.html#a8e4cded65a76ead28e3083f1c046234c" title="constant for double data type">tclmpi::double</a> is incomplete. The length of the data is inferred from the data object passed to this function and thus a 'count' argument is not needed. The number of data items has to be the same on all processes on the communicator.</p>
<p>The result is converted back into Tcl objects and passed up as result value to the calling Tcl code on the root processor. If the MPI call failed, an MPI error message is passed up as result instead. </p>

</div>
</div>
<a id="ga738cbe476e7ccfd4aced07b4dd433587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga738cbe476e7ccfd4aced07b4dd433587">&#9670;&nbsp;</a></span>TclMPI_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TclMPI_Init </td>
          <td>(</td>
          <td class="paramtype">ClientData&#160;</td>
          <td class="paramname"><em>nodata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Interp *&#160;</td>
          <td class="paramname"><em>interp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Obj *const&#160;</td>
          <td class="paramname"><em>objv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>wrapper for MPI_Init() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodata</td><td>ignored </td></tr>
    <tr><td class="paramname">interp</td><td>current Tcl interpreter </td></tr>
    <tr><td class="paramname">objc</td><td>number of argument objects </td></tr>
    <tr><td class="paramname">objv</td><td>list of argument object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TCL_OK or TCL_ERROR</dd></dl>
<p>This function does a little more work than just calling MPI_Init(). First of it tries to detect whether MPI_Init() has been called before (from Tcl) and then creates a (catchable) Tcl error instead of an (uncatchable) MPI error. It will also try to pass the argument vector to the script from the Tcl generated 'argv' array to the underlying MPI_Init() call and reset argv as needed. </p>

</div>
</div>
<a id="gaf143e6414be1d8e76b7dc88208df68b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf143e6414be1d8e76b7dc88208df68b2">&#9670;&nbsp;</a></span>TclMPI_Initialized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TclMPI_Initialized </td>
          <td>(</td>
          <td class="paramtype">ClientData&#160;</td>
          <td class="paramname"><em>nodata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Interp *&#160;</td>
          <td class="paramname"><em>interp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Obj *const&#160;</td>
          <td class="paramname"><em>objv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>wrapper for MPI_Initialized() </p><dl class="section return"><dt>Returns</dt><dd>TCL_OK or TCL_ERROR</dd></dl>
<p>This function checks whether the MPI environment has been initialized. </p>

</div>
</div>
<a id="ga2f7e89c72b47081da83f0c724d853d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f7e89c72b47081da83f0c724d853d68">&#9670;&nbsp;</a></span>TclMPI_Iprobe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TclMPI_Iprobe </td>
          <td>(</td>
          <td class="paramtype">ClientData&#160;</td>
          <td class="paramname"><em>nodata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Interp *&#160;</td>
          <td class="paramname"><em>interp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Obj *const&#160;</td>
          <td class="paramname"><em>objv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>wrapper for MPI_Iprobe() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodata</td><td>ignored </td></tr>
    <tr><td class="paramname">interp</td><td>current Tcl interpreter </td></tr>
    <tr><td class="paramname">objc</td><td>number of argument objects </td></tr>
    <tr><td class="paramname">objv</td><td>list of argument object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TCL_OK or TCL_ERROR</dd></dl>
<p>This function implements a non-blocking probe operation for TclMPI. Argument flags for source, tag, and communicator are translated into their native MPI equivalents and then MPI_Iprobe called.</p>
<p>Similar to MPI_Probe, generating a status object to inspect the pending receive is optional. If desired, the argument is taken as a variable name which will then be generated as associative array with several entries similar to what MPI_Status contains. Those are source, tag, error status and count, however this is directly provided as multiple entries translated to char, int and double data types (COUNT_CHAR, COUNT_INT, COUNT_DOUBLE).</p>
<p>The status flag in MPI_Iprobe that returns true if a request is pending will be passed to the calling routine as Tcl result. </p>

</div>
</div>
<a id="ga23b7bfee001ce295267c82286eacb977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23b7bfee001ce295267c82286eacb977">&#9670;&nbsp;</a></span>TclMPI_Irecv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TclMPI_Irecv </td>
          <td>(</td>
          <td class="paramtype">ClientData&#160;</td>
          <td class="paramname"><em>nodata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Interp *&#160;</td>
          <td class="paramname"><em>interp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Obj *const&#160;</td>
          <td class="paramname"><em>objv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>wrapper for MPI_Iecv() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodata</td><td>ignored </td></tr>
    <tr><td class="paramname">interp</td><td>current Tcl interpreter </td></tr>
    <tr><td class="paramname">objc</td><td>number of argument objects </td></tr>
    <tr><td class="paramname">objv</td><td>list of argument object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TCL_OK or TCL_ERROR</dd></dl>
<p>This function implements a non-blocking receive operation for TclMPI. Since the length of the data object is supposed to be automatically adjusted to the amount of data being sent, this function needs to be more complex than just a simple wrapper around the corresponding MPI C bindings. It will first call tclmpi_add_req to generate a new entry to the list of registered MPI requests. It will then call MPI_Iprobe to see if a matching send is already in progress and thus the necessary amount of storage required can be inferred from the MPI_Status object that is populated by MPI_Iprobe. If yes, a temporary receive buffer is allocated and the non-blocking receive is posted and all information is transferred to the tclmpi_req_t object. If not, only the arguments of the receive call are registered in the request object for later use. The command will pass the Tcl string that represents the generated MPI request to the Tcl interpreter as return value. If the MPI call failed, an MPI error message is passed up as result instead and a Tcl error is indicated. </p>

</div>
</div>
<a id="ga5a80dad483292f282deb68f37b014bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a80dad483292f282deb68f37b014bb8">&#9670;&nbsp;</a></span>TclMPI_Isend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TclMPI_Isend </td>
          <td>(</td>
          <td class="paramtype">ClientData&#160;</td>
          <td class="paramname"><em>nodata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Interp *&#160;</td>
          <td class="paramname"><em>interp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Obj *const&#160;</td>
          <td class="paramname"><em>objv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>wrapper for MPI_Isend() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodata</td><td>ignored </td></tr>
    <tr><td class="paramname">interp</td><td>current Tcl interpreter </td></tr>
    <tr><td class="paramname">objc</td><td>number of argument objects </td></tr>
    <tr><td class="paramname">objv</td><td>list of argument object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TCL_OK or TCL_ERROR</dd></dl>
<p>This function implements a non-blocking send operation for TclMPI. The length of the data is inferred from the data object passed to this function and thus a 'count' argument is not needed. Unlike for the blocking TclMPI_Send, in the case of <a class="el" href="namespacetclmpi.html#ab65b00584fb79d516e653ea35dece54e" title="constant for automatic data type">tclmpi::auto</a> as data a copy has to be made since the string representation of the send data might be invalidated during the send. The command generates a new tclmpi_req_t communication request via tclmpi_add_req and the pointers to the data buffer and the MPI_Request info generated by MPI_Isend is stored in this request list entry for later perusal, see TclMPI_Wait. The generated string label representing this request will be passed on to the calling program as Tcl result. If the MPI call failed, an MPI error message is passed up as result instead and a Tcl error is indicated. </p>

</div>
</div>
<a id="gab7f8f9e8a2e0415c15b859b742335f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7f8f9e8a2e0415c15b859b742335f6f">&#9670;&nbsp;</a></span>TclMPI_Probe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TclMPI_Probe </td>
          <td>(</td>
          <td class="paramtype">ClientData&#160;</td>
          <td class="paramname"><em>nodata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Interp *&#160;</td>
          <td class="paramname"><em>interp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Obj *const&#160;</td>
          <td class="paramname"><em>objv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>wrapper for MPI_Probe() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodata</td><td>ignored </td></tr>
    <tr><td class="paramname">interp</td><td>current Tcl interpreter </td></tr>
    <tr><td class="paramname">objc</td><td>number of argument objects </td></tr>
    <tr><td class="paramname">objv</td><td>list of argument object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TCL_OK or TCL_ERROR</dd></dl>
<p>This function implements a blocking probe operation for TclMPI. Argument flags for source, tag, and communicator are translated into their native MPI equivalents and then MPI_Probe called.</p>
<p>Similar to MPI_Probe, generating a status object to inspect the pending receive is optional. If desired, the argument is taken as a variable name which will then be generated as associative array with several entries similar to what MPI_Status contains. Those are source, tag, error status and count, however this is directly provided as multiple entries translated to char, int and double data types (COUNT_CHAR, COUNT_INT, COUNT_DOUBLE). </p>

</div>
</div>
<a id="gadf47d8f1880c12269033d3c85aa561e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf47d8f1880c12269033d3c85aa561e9">&#9670;&nbsp;</a></span>TclMPI_Recv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TclMPI_Recv </td>
          <td>(</td>
          <td class="paramtype">ClientData&#160;</td>
          <td class="paramname"><em>nodata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Interp *&#160;</td>
          <td class="paramname"><em>interp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Obj *const&#160;</td>
          <td class="paramname"><em>objv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>wrapper for MPI_Recv() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodata</td><td>ignored </td></tr>
    <tr><td class="paramname">interp</td><td>current Tcl interpreter </td></tr>
    <tr><td class="paramname">objc</td><td>number of argument objects </td></tr>
    <tr><td class="paramname">objv</td><td>list of argument object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TCL_OK or TCL_ERROR</dd></dl>
<p>This function implements a blocking receive operation for TclMPI. Since the length of the data object is supposed to be automatically adjusted to the amount of data being sent, this function will first call MPI_Probe to identify the amount of storage needed from the MPI_Status object that is populated by MPI_Probe. Then a temporary receive buffer is allocated and then converted back to Tcl objects according to the data type passed to the receive command. Due to this deviation from the MPI C bindings a 'count' argument is not needed. This command returns the received data to the calling procedure. If the MPI call failed, an MPI error message is passed up as result instead and a Tcl error is indicated. </p>

</div>
</div>
<a id="ga21fffcb1b06117177f8cb64c0d13b4cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21fffcb1b06117177f8cb64c0d13b4cf">&#9670;&nbsp;</a></span>TclMPI_Reduce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TclMPI_Reduce </td>
          <td>(</td>
          <td class="paramtype">ClientData&#160;</td>
          <td class="paramname"><em>nodata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Interp *&#160;</td>
          <td class="paramname"><em>interp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Obj *const&#160;</td>
          <td class="paramname"><em>objv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>wrapper for MPI_Reduce() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodata</td><td>ignored </td></tr>
    <tr><td class="paramname">interp</td><td>current Tcl interpreter </td></tr>
    <tr><td class="paramname">objc</td><td>number of argument objects </td></tr>
    <tr><td class="paramname">objv</td><td>list of argument object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TCL_OK or TCL_ERROR</dd></dl>
<p>This function implements a reduction function for TclMPI. This operation does not accept the <a class="el" href="namespacetclmpi.html#ab65b00584fb79d516e653ea35dece54e" title="constant for automatic data type">tclmpi::auto</a> data type, also support for types outside of <a class="el" href="namespacetclmpi.html#a1cabae47e0cff6dfb26f3013347158ac" title="constant for integer data type">tclmpi::int</a> and <a class="el" href="namespacetclmpi.html#a8e4cded65a76ead28e3083f1c046234c" title="constant for double data type">tclmpi::double</a> is incomplete. The length of the data is inferred from the data object passed to this function and thus a 'count' argument is not needed.</p>
<p>The result is collected on the process with rank root and converted back into Tcl objects and passed up as result value to the calling Tcl code. If the MPI call failed an MPI error message is passed up as result instead. </p>

</div>
</div>
<a id="ga337b5793693835724b4e705e533a5091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga337b5793693835724b4e705e533a5091">&#9670;&nbsp;</a></span>TclMPI_Scatter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TclMPI_Scatter </td>
          <td>(</td>
          <td class="paramtype">ClientData&#160;</td>
          <td class="paramname"><em>nodata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Interp *&#160;</td>
          <td class="paramname"><em>interp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Obj *const&#160;</td>
          <td class="paramname"><em>objv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>wrapper for MPI_Scatter() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodata</td><td>ignored </td></tr>
    <tr><td class="paramname">interp</td><td>current Tcl interpreter </td></tr>
    <tr><td class="paramname">objc</td><td>number of argument objects </td></tr>
    <tr><td class="paramname">objv</td><td>list of argument object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TCL_OK or TCL_ERROR</dd></dl>
<p>This function implements a scatter operation that distributes data for TclMPI. This operation does not accept the <a class="el" href="namespacetclmpi.html#ab65b00584fb79d516e653ea35dece54e" title="constant for automatic data type">tclmpi::auto</a> data type, also support for types outside of <a class="el" href="namespacetclmpi.html#a1cabae47e0cff6dfb26f3013347158ac" title="constant for integer data type">tclmpi::int</a> and <a class="el" href="namespacetclmpi.html#a8e4cded65a76ead28e3083f1c046234c" title="constant for double data type">tclmpi::double</a> is incomplete. The length of the data is inferred from the data object passed to this function and thus a 'count' argument is not needed. The number of data items has to be divisible by the number of processes on the communicator.</p>
<p>The result is converted back into Tcl objects and passed up as result value to the calling Tcl code. If the MPI call failed an MPI error message is passed up as result instead. </p>

</div>
</div>
<a id="gafcf9e8effd1a99b4aed1e17e8b9bc2e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcf9e8effd1a99b4aed1e17e8b9bc2e3">&#9670;&nbsp;</a></span>TclMPI_Send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TclMPI_Send </td>
          <td>(</td>
          <td class="paramtype">ClientData&#160;</td>
          <td class="paramname"><em>nodata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Interp *&#160;</td>
          <td class="paramname"><em>interp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Obj *const&#160;</td>
          <td class="paramname"><em>objv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>wrapper for MPI_Send() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodata</td><td>ignored </td></tr>
    <tr><td class="paramname">interp</td><td>current Tcl interpreter </td></tr>
    <tr><td class="paramname">objc</td><td>number of argument objects </td></tr>
    <tr><td class="paramname">objv</td><td>list of argument object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TCL_OK or TCL_ERROR</dd></dl>
<p>This function implements a blocking send operation for TclMPI. The length of the data is inferred from the data object passed to this function and thus a 'count' argument is not needed. In the case of <a class="el" href="namespacetclmpi.html#ab65b00584fb79d516e653ea35dece54e" title="constant for automatic data type">tclmpi::auto</a>, the string representation of the send data is directly passed to MPI_Send() otherwise a copy is made and data converted.</p>
<p>If the MPI call failed, an MPI error message is passed up as result instead and a Tcl error is indicated, otherwise nothing is returned. </p>

</div>
</div>
<a id="ga69a2797d86eb85cf481686f7f13d2470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69a2797d86eb85cf481686f7f13d2470">&#9670;&nbsp;</a></span>TclMPI_Wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TclMPI_Wait </td>
          <td>(</td>
          <td class="paramtype">ClientData&#160;</td>
          <td class="paramname"><em>nodata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Interp *&#160;</td>
          <td class="paramname"><em>interp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tcl_Obj *const&#160;</td>
          <td class="paramname"><em>objv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>wrapper for MPI_Wait() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodata</td><td>ignored </td></tr>
    <tr><td class="paramname">interp</td><td>current Tcl interpreter </td></tr>
    <tr><td class="paramname">objc</td><td>number of argument objects </td></tr>
    <tr><td class="paramname">objv</td><td>list of argument object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TCL_OK or TCL_ERROR</dd></dl>
<p>This function implements a wrapper around MPI_Wait for TclMPI. Due to the design decisions in TclMPI, it works a bit different than MPI_Wait, particularly for non-blocking receive requests. As explained in the TclMPI_Irecv documentation, the corresponding MPI_Irecv may not yet have been posted, so we have to first inspect the tclmpi_req_t object, if the receive still needs to be posted. If yes, then we need to do about the same procedure as for a blocking receive, i.e. call MPI_Probe to determine the size of the receive buffer, allocate that buffer and then post a blocking receive. If no, we call MPI_Wait to wait until the non-blocking receive is completed. In both cases, the result needed to be converted to Tcl objects and passed to the calling procedure as Tcl return values. Then the receive buffers can be deleted and the tclmpi_req_t entry removed from it translation table.</p>
<p>For non-blocking send requests, MPI_Wait is called and after completion the send buffer freed and the tclmpi_req_t data released. The MPI spec allows to call MPI_Wait on non-existing MPI_Requests and just return immediately. This is handled directly without calling MPI_Wait, since we cache all generated MPI requests. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
